
# WebRTC (Web Real-Time Communication)

## 개요

WebRTC는 **Web Real-Time Communication**의 약자로, 웹 애플리케이션이나 웹 사이트에서 실시간으로 음성, 영상, 데이터 통신을 지원하는 기술입니다. WebRTC는 기본적으로 **peer-to-peer(P2P)** 연결을 통해 데이터를 주고받으며, 이를 위해 몇 가지 중요한 구성 요소가 필요합니다.

---

## 주요 구성 요소

### 1. **Signaling Server**
WebRTC는 P2P 연결을 기반으로 하지만, P2P 연결을 설정하기 위해서는 **Session Description Protocol(SDP)** 및 **Interactive Connectivity Establishment(ICE)**와 같은 정보를 교환할 수 있는 **시그널링** 과정이 필요합니다. 이를 위해 시그널링 서버가 필요합니다.

- **SDP (Session Description Protocol)**: 연결을 위한 메타데이터(코덱, 미디어 형식, 포트번호 등)를 포함한 정보를 교환하는 프로토콜입니다.
- **ICE (Interactive Connectivity Establishment)**: P2P 연결을 설정하는 과정에서, 두 피어가 서로 통신할 수 있는 최적의 경로를 찾아주는 메커니즘입니다.

시그널링 서버는 주로 **웹소켓(WebSocket)**을 사용하여 실시간으로 데이터를 교환합니다. REST API로 구현할 수도 있지만, 실시간 통신의 특성상 **웹소켓**이 더 적합합니다. REST API를 사용할 경우, **Polling** 또는 **Long Polling** 기법을 이용해 실시간성을 확보해야 합니다.

### 2. **STUN Server**
STUN(Session Traversal Utilities for NAT) 서버는 NAT(Network Address Translation) 환경에서 공인 IP 주소를 확보하고, 이를 통해 P2P 연결을 지원하는 서버입니다.

- **NAT 환경**: 클라이언트가 사설 IP 주소를 사용하고 있을 때, 외부 네트워크와 통신하기 위해 NAT을 거쳐야 합니다. STUN 서버는 클라이언트가 공인 IP 주소와 포트를 얻을 수 있도록 도와줍니다.
- STUN은 **Reflexive Transport Address**를 제공하여, 클라이언트의 사설 IP 주소를 공인 IP 주소로 변환할 수 있도록 합니다.
- 단, **같은 NAT 환경에 있는 두 단말** 간에는 STUN이 제대로 동작하지 않을 수 있습니다.

### 3. **TURN Server**
TURN(Traversal Using Relays around NAT) 서버는 STUN 서버로도 해결할 수 없는 복잡한 NAT 환경에서 P2P 연결을 돕는 중계 서버입니다.

- TURN 서버는 **릴레이 서버**로서, 두 피어 간의 데이터가 직접 전송될 수 없는 경우, 중간에서 데이터를 릴레이하는 역할을 합니다.
- **복잡한 NAT 환경**, **방화벽** 문제 또는 **네트워크 상태의 일시적 변화** 등으로 인해 직접적인 P2P 연결이 불가능할 때 TURN 서버가 사용됩니다.
- TURN 서버를 사용할 경우, 서버가 데이터를 중계하므로 성능이 저하될 수 있습니다.

### 4. **ICE (Interactive Connectivity Establishment)**
ICE는 두 피어 간에 최적의 연결 경로를 설정하는 메커니즘으로, P2P 연결을 설정하는 데 필수적인 역할을 합니다.

- **ICE 과정**은 여러 후보 주소를 식별하고, 이 중에서 가장 효율적인 경로를 선택하여 두 피어 간의 연결을 설정합니다.
- **ICE 후보**는 다음과 같은 형태로 구분됩니다:
  - **Local Address**: 클라이언트의 사설 IP 주소와 포트 번호.
  - **Server Reflexive Address**: STUN 서버를 통해 얻은 공인 IP 주소와 포트 번호.
  - **Relayed Address**: TURN 서버를 통해 릴레이된 IP 주소와 포트 번호.

ICE는 두 피어 간의 최적 경로를 찾고, 연결을 설정하는데 필요한 정보를 주고받기 위해 **SDP Offer**와 **SDP Answer**를 사용하여 서로 통신합니다.

---

## 요약
WebRTC는 실시간 통신을 위한 기술로, P2P 연결을 통해 음성, 영상, 데이터를 주고받습니다. 이 과정에서 **시그널링 서버**를 통해 SDP와 ICE 정보를 교환하고, **STUN**과 **TURN** 서버를 활용하여 NAT 환경을 통과합니다. **ICE**는 최적의 연결 경로를 찾아 피어 간의 안정적인 연결을 돕는 중요한 역할을 합니다.

---

# JPA (Java Persistence API)

## JPA란?
- **JPA (Java Persistence API)**는 자바 객체와 관계형 데이터베이스 간의 매핑을 제공하는 **ORM (Object-Relational Mapping)** 표준 인터페이스입니다.
- JPA는 **하이버네티스 (Hibernate)**와 같은 ORM 프레임워크를 기반으로 구현됩니다.
- JPA는 SQL 쿼리를 직접 작성하는 대신 자바 객체와 데이터베이스의 테이블 간의 관계를 설정하고, 객체지향적으로 데이터를 처리할 수 있도록 도와줍니다.

## JPA의 주요 개념

### 1. 영속성 컨텍스트 (Persistence Context)
영속성 컨텍스트는 **영속성 상태를 관리**하는 객체의 집합으로, 엔티티 객체와 데이터베이스 간의 상태 변화를 관리합니다.

- **영속성 상태 변화**:
  - `transient` → `managed` → `detached` → `DB`
  - `transient`: 영속성 컨텍스트와 연결되지 않은 상태의 객체
  - `managed`: 영속성 컨텍스트에 의해 관리되는 상태의 객체
  - `detached`: 영속성 컨텍스트에서 분리된 객체
  - `DB`: 데이터베이스에 저장된 상태

영속성 컨텍스트는 JPA가 객체의 상태 변경을 추적하고, 데이터베이스와 동기화하는 기능을 제공합니다.

### 2. 1차 캐시 (1st Level Cache)
- **최초 `find` 호출** 시, 해당 엔티티는 영속성 컨텍스트에 저장되어 **1차 캐시**로 관리됩니다.
- 이후 동일한 엔티티를 조회할 때, DB에서 조회하는 대신 **영속성 컨텍스트에서 캐싱된 데이터를 반환**합니다.
  
### 3. 동일성 보장 (Identity Guarantee)
- JPA는 동일성 보장을 제공합니다. 즉, **같은 엔티티는 동일한 자바 객체로 취급**됩니다.
- 예를 들어, 같은 ID를 가진 두 엔티티 객체는 동일한 객체로 간주됩니다.

### 4. 객체 업데이트 감지
- JPA는 객체의 상태 변화를 감지하고 이를 DB에 반영하는 기능을 제공합니다.
- **트랜잭션 커밋 시**, JPA는 영속성 컨텍스트에 있는 객체들의 상태를 확인하고, 변경 사항이 있을 경우 DB에 업데이트 쿼리를 자동으로 실행합니다.
- 이를 통해 개발자는 객체의 상태 변화만 관리하면 되고, DB와의 동기화는 JPA가 자동으로 처리합니다.

## 엔티티 생명 주기

- **transient**: 객체가 JPA 관리 대상이 아닌 상태입니다.
- **managed**: 객체가 영속성 컨텍스트에서 관리되는 상태입니다. 영속성 컨텍스트에 의해 객체의 상태 변화가 추적됩니다.
- **detached**: 객체가 영속성 컨텍스트에서 분리된 상태입니다. 더 이상 JPA가 객체를 관리하지 않습니다.
- **removed**: 객체가 삭제되었으며, 영속성 컨텍스트에서 삭제될 때 DB에서 해당 데이터도 삭제됩니다.

## JPA 사용 시의 주요 장점
- **객체 지향적 접근**: SQL 쿼리를 직접 작성하지 않고, 자바 객체를 통해 데이터를 처리할 수 있습니다.
- **자동화된 트랜잭션 관리**: 객체 상태 변경 시, JPA가 자동으로 DB와의 동기화를 처리합니다.
- **1차 캐시**를 통해 DB 접근을 최소화하고 성능을 최적화할 수 있습니다.
- **관계형 데이터베이스와의 매핑**을 통해 객체지향 개발이 가능합니다.



# 인증 / 인가
## jwt refresh token
## bcrypt 암호화