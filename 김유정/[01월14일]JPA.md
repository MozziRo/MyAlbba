### JPA(Java Persistent API)
자바 진영의 ORM(Object Relational Mapping) 기술 표준으로, 자바에서 객체와 데이터베이스 간의 데이터를 관리하기 위한 표준 인터페이스이다.

![스크린샷_2025-01-14_22.03.42](/uploads/ff99bbf0ce97901d5111764da9d3828e/스크린샷_2025-01-14_22.03.42.png)

### JPA의 주요 특징
1. ORM(Object-Relational Mapping)
- JPA는 객체와 관계형 데이터베이스를 매핑하는 ORM 도구이다.
- 객체 지향적인 방식으로 데이터를 다룰 수 있게 해주어, SQL 문장을 작성하지 않고도 데이터베이스 작업을 수행할 수 있다.

### JPA의 주요 이점
1. 생산성 향상:
- SQL을 직접 작성하는 수고를 덜어주고, 자바 코드만으로 데이터를 처리할 수 있다.
2. 유지보수 용이:
- 데이터베이스 스키마 변경 시 JPA 엔티티 클래스만 수정하면 된다.
- 비즈니스 로직과 데이터 접근 로직이 분리된다.
3. 객체 지향적인 데이터베이스 처리:
- 데이터베이스의 테이블 구조를 객체지향적인 엔티티로 추상화해 처리할 수 있다.
- 데이터베이스 레코드를 엔티티 객체로 매핑한다.
4. 데이터베이스 독립성:
- 데이터베이스 벤더(Oracle, MySQL, PostgreSQL 등)에 종속되지 않고, 표준 인터페이스를 사용한다.

### JPA의 기본 작동 원리
1. 엔티티(Entity):
- 데이터베이스 테이블과 매핑되는 클래스
- @Entity, @Table 어노테이션 사용

2. 엔티티 매니저(Entity Manager):
* 데이터베이스와의 연결을 관리하며, CRUD 작업을 처리한다.
* 주요 메서드:
    - persist(entity): 엔티티를 영속성 컨텍스트에 새롭게 저장한다.
        + 영속성 컨텍스트에 엔티티가 없으면 SQL 실행 시 INSERT 쿼리가 실행된다.
    - find(Class<T>, id): 특정 ID로 엔티티를 조회한다.
    - remove(entity): 엔티티를 삭제한다.
    - merge(entity) : 엔티티를 업데이트한다.
        + 준영속 상태의 엔티티를 다시 영속성 컨텍스트로 관리하게 만든다.
        + 이미 DB에 존재하는 엔티티를 수정하거나 다시 연결할 때 사용한다.

3. 영속성 컨텍스트(Persistence Context)
* 엔티티 매니저가 관리하는 엔티티 객체들의 저장소이다.
* 엔티티를 영구 저장하는 환경이라는 의미로, 눈에 보이지 않는 논리적인 개념이다.
* 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.
* JPA에서 엔티티 객체를 영속 상태로 만들고, 이를 1차 캐시, 변경 감지, 지연 로딩 같은 기능을 제공한다.
![스크린샷_2025-01-14_23.03.06](/uploads/2ccb6b91d72c35cb4949e8f6ba135df6/스크린샷_2025-01-14_23.03.06.png)
![스크린샷_2025-01-14_23.03.47](/uploads/92c0e1211b11991f295df4572bf0ce88/스크린샷_2025-01-14_23.03.47.png)
    - 1차 캐시
        + 영속성 컨텍스트 내부에 엔티티를 캐싱하여 데이터베이스 접근을 줄인다.
        + 동일한 트랜잭션 내에서 동일한 엔티티를 조회할 때, DB를 조회하지 않고 메모리에서 가져온다.
        + 같은 엔티티를 반복 조회해도 데이터베이스를 다시 쿼리하지 않는다.
        + em.find()를 호출하면 1차 캐시를 먼저 확인한다.
        + em.persist(member)로 객체를 영속화하면 각 EntityManager에서 관리하는 1차 캐시에 객체를 저장한다. 실제 DB에 저장되는 시점은 트랙잭션이 Commit될 때이므로 같은 트랙재션에서 객체가 변경되는 정보들을 모아서 한 번에 쿼리를 날린다.
    - 쓰기 지연(Batch Insert/Update)
        + 트랜잭션이 커밋되기 전까지 INSERT, UPDATE, DELETE SQL을 쿼리로 저장만 하고, 실제 실행은 지연한다.
        + 성능 최적화를 위해 여러 쿼리를 모아 한 번에 실행한다.
        + persist()로 엔티티를 영속성 컨텍스트에 저장하고 트랜잭션이 commit()되면 SQL이 실행된다.
    - 변경 감지(Dirty Checking)
        + 영속성 컨텍스트가 관리 중인 엔티티의 변경 사항을 감지하여, 트랜잭션 커밋 시점에 자동으로 업데이트 쿼리를 실행한다.
        + 작동 과정 : 트랜잭션 시작 -> 엔티티의 값을 변경 -> 트랜잭션 커밋 시점에 변경 사항을 찾아 UPDATE 쿼리 실행
    - 지연 로딩(Lazy Loading)
        + 연관된 엔티티를 처음부터 불러오지 않고, 실제로 사용할 때 가져오는 방식이다.
        + 성능 최적화에 유리하다.
        + 즉시 로딩은 연관된 엔티티를 즉시 조회하지만 지연 로딩은 연관된 엔티티를 프록시 객체로 생성하고, 실제 접근 시 데이터베이스에서 조회한다.

* 상태 종류:
    - 비영속(New): 영속성 컨텍스트에 포함되지 않은 상태이다.
    - 영속(Managed): 영속성 컨텍스트에 포함되어 관리되는 상태이다.
    - 준영속(Detached): 영속성 컨텍스트에서 분리된 상태이다. (?)
    - 삭제(Removed): 삭제된 상태이다.

3. JPQL(Java Persistence Query Language):
- 객체를 대상으로 쿼리를 작성하는 언어
- SQL과 유사하지만, 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 한다.

4. 트랜잭션 관리:
- 데이터 작업은 트랜잭션 내에서 이루어져야 한다.
- Spring에서는 보통 @Transactional 어노테이션으로 관리한다.

